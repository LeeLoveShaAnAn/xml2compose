<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F2G7TSB6Q6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-F2G7TSB6Q6');
    </script>
    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2819959179592334" 
      crossorigin="anonymous"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mastering State Management in Jetpack Compose - xml2compose.dev</title>
    <meta name="description" content="Deep dive into Jetpack Compose state management patterns, from basic remember to advanced state hoisting and ViewModel integration.">
    
    <!-- Favicon -->
    <link rel="icon" href="../favicon.ico" type="image/x-icon">
    
    <!-- SEO Meta Tags -->
    <link rel="canonical" href="https://xml2compose.dev/blog/compose-state-management.html">
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
    <meta property="og:title" content="Mastering State Management in Jetpack Compose">
    <meta property="og:description" content="Deep dive into Jetpack Compose state management patterns, from basic remember to advanced state hoisting and ViewModel integration.">
    <meta property="og:image" content="https://images.unsplash.com/photo-1517180102446-f3ece451e9d8?w=1200&h=630&fit=crop">
    <meta property="og:url" content="https://xml2compose.dev/blog/compose-state-management.html">
    <meta property="og:type" content="article">
    
    <link rel="stylesheet" href="../style.css">
    <style>
        /* Article-specific styles */
        .main {
            min-height: calc(100vh - 64px - 200px);
            padding: var(--space-12) 0;
        }
        
        .article {
            background-color: var(--bg-primary);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-md);
            overflow: hidden;
            border: 1px solid var(--border-secondary);
        }
        
        .article-header {
            padding: var(--space-12) var(--space-8) var(--space-8);
            background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-primary) 100%);
        }
        
        .article-title {
            font-size: clamp(var(--text-3xl), 4vw, var(--text-5xl));
            font-weight: var(--font-bold);
            line-height: var(--leading-tight);
            margin-bottom: var(--space-4);
            color: var(--text-primary);
            letter-spacing: -0.025em;
        }
        
        .article-meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-6);
            font-size: var(--text-sm);
            color: var(--text-secondary);
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: var(--space-1);
        }
        
        .meta-icon {
            width: 1rem;
            height: 1rem;
            opacity: 0.6;
        }
        
        .article-content {
            padding: 0 var(--space-8) var(--space-12);
        }
        
        .article-content > * + * {
            margin-top: var(--space-6);
        }
        
        .article-content h2 {
            font-size: var(--text-3xl);
            font-weight: var(--font-bold);
            margin-top: var(--space-12);
            margin-bottom: var(--space-4);
            color: var(--text-primary);
        }
        
        .article-content h3 {
            font-size: var(--text-2xl);
            font-weight: var(--font-semibold);
            margin-top: var(--space-8);
            margin-bottom: var(--space-3);
            color: var(--text-primary);
        }
        
        .article-content p {
            color: var(--text-secondary);
            line-height: var(--leading-relaxed);
            font-size: var(--text-lg);
        }
        
        .article-content a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: var(--font-medium);
            border-bottom: 1px solid transparent;
            transition: border-color var(--transition-fast);
        }
        
        .article-content a:hover {
            border-bottom-color: var(--primary-color);
        }
        
        .code-block {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
            border-radius: var(--radius-md);
            overflow: hidden;
            margin: var(--space-6) 0;
        }
        
        .code-header {
            background-color: var(--bg-secondary);
            padding: var(--space-3) var(--space-4);
            border-bottom: 1px solid var(--border-secondary);
            font-size: var(--text-sm);
            color: var(--text-secondary);
            font-weight: var(--font-medium);
        }
        
        pre {
            padding: var(--space-4);
            overflow-x: auto;
            font-size: var(--text-sm);
            line-height: var(--leading-normal);
            margin: 0;
            font-family: var(--font-mono);
        }
        
        code {
            font-family: var(--font-mono);
            color: var(--text-primary);
        }
        
        .article-content p code {
            background-color: var(--bg-tertiary);
            padding: var(--space-1) var(--space-2);
            border-radius: var(--radius-sm);
            font-size: 0.875em;
            color: var(--accent-color);
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 2rem;
            transition: color 0.2s;
        }
        
        .back-link:hover {
            color: var(--secondary-color);
        }
        
        .back-icon {
            width: 1rem;
            height: 1rem;
        }
        
        @media (max-width: 768px) {
            .article-title {
                font-size: 2rem;
            }
            
            .article-header {
                padding: 2rem 1.5rem 1.5rem;
            }
            
            .article-content {
                padding: 0 1.5rem 2rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="logo">
                <h1 class="logo-text"><a href="../index.html">xml2compose.dev</a></h1>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../converter.html">Converter</a></li>
                    <li><a href="../blog.html">Blog</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <a href="../blog.html" class="back-link">
                <svg class="back-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
                Back to Blog
            </a>
            
            <article class="article">
                <header class="article-header">
                    <h1 class="article-title">Mastering State Management in Jetpack Compose</h1>
                    <div class="article-meta">
                        <span class="meta-item">
                            <svg class="meta-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            January 20, 2025
                        </span>
                        <span class="meta-item">
                            <svg class="meta-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            10 min read
                        </span>
                        <span class="meta-item">
                            <svg class="meta-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                            </svg>
                            xml2compose Team
                        </span>
                    </div>
                </header>

                <div class="article-content">
                    <p>State management is the cornerstone of building reactive and efficient UI in Jetpack Compose. Understanding how to properly manage state not only ensures your app performs well but also makes your code more maintainable and testable. In this comprehensive guide, we'll explore various state management patterns and best practices.</p>

                    <h2>Understanding State in Compose</h2>

                    <p>In Compose, state represents any value that can change over time and affects the UI. When state changes, Compose automatically recomposes (redraws) only the parts of the UI that depend on that state.</p>

                    <h3>Basic State with remember</h3>

                    <p>The simplest way to manage state in Compose is using <code>remember</code> and <code>mutableStateOf</code>:</p>

                    <div class="code-block">
                        <div class="code-header">BasicState.kt</div>
                        <pre><code>@Composable
fun CounterExample() {
    var count by remember { mutableStateOf(0) }
    
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.padding(16.dp)
    ) {
        Text(
            text = "Count: $count",
            style = MaterialTheme.typography.headlineMedium
        )
        
        Row(
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Button(onClick = { count-- }) {
                Text("-")
            }
            Button(onClick = { count++ }) {
                Text("+")
            }
        }
    }
}</code></pre>
                    </div>

                    <h3>State Hoisting</h3>

                    <p>State hoisting is a pattern where you move state up to the common ancestor of composables that need to share it. This makes your composables stateless and more reusable:</p>

                    <div class="code-block">
                        <div class="code-header">StateHoisting.kt</div>
                        <pre><code>@Composable
fun TodoApp() {
    var todos by remember { mutableStateOf(listOf<Todo>()) }
    
    Column {
        TodoInput(
            onTodoAdd = { newTodo ->
                todos = todos + newTodo
            }
        )
        
        TodoList(
            todos = todos,
            onTodoToggle = { todo ->
                todos = todos.map { 
                    if (it.id == todo.id) it.copy(completed = !it.completed) 
                    else it 
                }
            }
        )
    }
}

@Composable
fun TodoInput(onTodoAdd: (Todo) -> Unit) {
    var text by remember { mutableStateOf("") }
    
    Row(
        modifier = Modifier.padding(16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        OutlinedTextField(
            value = text,
            onValueChange = { text = it },
            label = { Text("New Todo") },
            modifier = Modifier.weight(1f)
        )
        
        Button(
            onClick = {
                if (text.isNotBlank()) {
                    onTodoAdd(Todo(text = text.trim()))
                    text = ""
                }
            },
            modifier = Modifier.padding(start = 8.dp)
        ) {
            Text("Add")
        }
    }
}</code></pre>
                    </div>

                    <h2>Advanced State Management</h2>

                    <h3>Using ViewModel</h3>

                    <p>For complex state logic and to survive configuration changes, use ViewModel with Compose:</p>

                    <div class="code-block">
                        <div class="code-header">TodoViewModel.kt</div>
                        <pre><code>class TodoViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(TodoUiState())
    val uiState: StateFlow<TodoUiState> = _uiState.asStateFlow()
    
    fun addTodo(text: String) {
        val newTodo = Todo(
            id = UUID.randomUUID().toString(),
            text = text,
            completed = false
        )
        
        _uiState.update { currentState ->
            currentState.copy(
                todos = currentState.todos + newTodo
            )
        }
    }
    
    fun toggleTodo(todoId: String) {
        _uiState.update { currentState ->
            currentState.copy(
                todos = currentState.todos.map { todo ->
                    if (todo.id == todoId) {
                        todo.copy(completed = !todo.completed)
                    } else todo
                }
            )
        }
    }
    
    fun deleteTodo(todoId: String) {
        _uiState.update { currentState ->
            currentState.copy(
                todos = currentState.todos.filter { it.id != todoId }
            )
        }
    }
}

data class TodoUiState(
    val todos: List<Todo> = emptyList(),
    val isLoading: Boolean = false,
    val errorMessage: String? = null
)</code></pre>
                    </div>

                    <p>Using the ViewModel in your Composable:</p>

                    <div class="code-block">
                        <div class="code-header">TodoScreen.kt</div>
                        <pre><code>@Composable
fun TodoScreen(
    viewModel: TodoViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    TodoContent(
        uiState = uiState,
        onAddTodo = viewModel::addTodo,
        onToggleTodo = viewModel::toggleTodo,
        onDeleteTodo = viewModel::deleteTodo
    )
}

@Composable
fun TodoContent(
    uiState: TodoUiState,
    onAddTodo: (String) -> Unit,
    onToggleTodo: (String) -> Unit,
    onDeleteTodo: (String) -> Unit
) {
    Column {
        TodoInput(onTodoAdd = onAddTodo)
        
        if (uiState.isLoading) {
            Box(
                modifier = Modifier.fillMaxWidth(),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        }
        
        LazyColumn {
            items(uiState.todos) { todo ->
                TodoItem(
                    todo = todo,
                    onToggle = { onToggleTodo(todo.id) },
                    onDelete = { onDeleteTodo(todo.id) }
                )
            }
        }
    }
}</code></pre>
                    </div>

                    <h3>Derived State</h3>

                    <p>Use <code>derivedStateOf</code> when you need to compute state based on other state values. This optimization prevents unnecessary recompositions:</p>

                    <div class="code-block">
                        <div class="code-header">DerivedState.kt</div>
                        <pre><code>@Composable
fun TodoStatistics(todos: List<Todo>) {
    val completedCount by remember {
        derivedStateOf {
            todos.count { it.completed }
        }
    }
    
    val pendingCount by remember {
        derivedStateOf {
            todos.count { !it.completed }
        }
    }
    
    val completionPercentage by remember {
        derivedStateOf {
            if (todos.isEmpty()) 0f
            else completedCount.toFloat() / todos.size
        }
    }
    
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Statistics",
                style = MaterialTheme.typography.headlineSmall
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Text("Total: ${todos.size}")
            Text("Completed: $completedCount")
            Text("Pending: $pendingCount")
            
            LinearProgressIndicator(
                progress = completionPercentage,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 8.dp)
            )
        }
    }
}</code></pre>
                    </div>

                    <h2>State Management Best Practices</h2>

                    <h3>1. Single Source of Truth</h3>

                    <p>Keep state in the lowest common ancestor and pass it down through parameters. This ensures data consistency and makes debugging easier.</p>

                    <h3>2. Unidirectional Data Flow</h3>

                    <p>Data should flow down through parameters, and events should flow up through callbacks. This pattern makes your app more predictable and testable.</p>

                    <div class="code-block">
                        <div class="code-header">UnidirectionalFlow.kt</div>
                        <pre><code>@Composable
fun SearchScreen(
    viewModel: SearchViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    SearchContent(
        query = uiState.query,
        results = uiState.results,
        isLoading = uiState.isLoading,
        onQueryChange = viewModel::updateQuery,
        onSearch = viewModel::search,
        onResultClick = viewModel::selectResult
    )
}</code></pre>
                    </div>

                    <h3>3. Immutable Data</h3>

                    <p>Use immutable data classes for your state. This prevents accidental mutations and makes state changes explicit:</p>

                    <div class="code-block">
                        <div class="code-header">ImmutableState.kt</div>
                        <pre><code>@Immutable
data class UserProfile(
    val name: String,
    val email: String,
    val avatar: String,
    val preferences: UserPreferences
) {
    fun updateName(newName: String) = copy(name = newName)
    fun updateEmail(newEmail: String) = copy(email = newEmail)
}

@Immutable
data class UserPreferences(
    val theme: Theme,
    val notifications: Boolean,
    val language: String
)</code></pre>
                    </div>

                    <h3>4. State Scoping</h3>

                    <p>Keep state as close as possible to where it's used. Don't lift state higher than necessary:</p>

                    <ul style="margin: 1rem 0; padding-left: 2rem; color: var(--text-secondary);">
                        <li style="margin: 0.5rem 0;">Use <code>remember</code> for UI-only state that doesn't need to survive configuration changes</li>
                        <li style="margin: 0.5rem 0;">Use <code>rememberSaveable</code> for UI state that should survive configuration changes</li>
                        <li style="margin: 0.5rem 0;">Use ViewModel for business logic state and data that outlives the composition</li>
                        <li style="margin: 0.5rem 0;">Use external state holders (Repository, UseCase) for app-wide state</li>
                    </ul>

                    <h2>Performance Considerations</h2>

                    <h3>Avoiding Unnecessary Recompositions</h3>

                    <p>Compose is smart about recomposition, but you can help it by following these guidelines:</p>

                    <div class="code-block">
                        <div class="code-header">OptimizedComposable.kt</div>
                        <pre><code>// ❌ This will cause unnecessary recompositions
@Composable
fun ExpensiveList(items: List<Item>) {
    LazyColumn {
        items(items) { item ->
            ExpensiveItem(
                item = item,
                onClick = { /* Handle click */ }, // New lambda every recomposition
                modifier = Modifier.padding(8.dp) // New modifier every recomposition
            )
        }
    }
}

// ✅ Optimized version
@Composable
fun OptimizedList(
    items: List<Item>,
    onItemClick: (Item) -> Unit,
    modifier: Modifier = Modifier
) {
    LazyColumn(modifier = modifier) {
        items(
            items = items,
            key = { it.id } // Provide stable keys
        ) { item ->
            ExpensiveItem(
                item = item,
                onClick = { onItemClick(item) }
            )
        }
    }
}</code></pre>
                    </div>

                    <h2>Testing State Management</h2>

                    <p>Proper state management makes testing easier. Here's how to test your state logic:</p>

                    <div class="code-block">
                        <div class="code-header">ViewModelTest.kt</div>
                        <pre><code>@Test
fun `when addTodo is called, todo is added to the list`() = runTest {
    val viewModel = TodoViewModel()
    
    viewModel.addTodo("Test todo")
    
    val uiState = viewModel.uiState.value
    assertEquals(1, uiState.todos.size)
    assertEquals("Test todo", uiState.todos.first().text)
    assertFalse(uiState.todos.first().completed)
}

@Test
fun `when toggleTodo is called, todo completion status changes`() = runTest {
    val viewModel = TodoViewModel()
    viewModel.addTodo("Test todo")
    
    val todoId = viewModel.uiState.value.todos.first().id
    viewModel.toggleTodo(todoId)
    
    val updatedTodo = viewModel.uiState.value.todos.first()
    assertTrue(updatedTodo.completed)
}</code></pre>
                    </div>

                    <h2>Conclusion</h2>

                    <p>Mastering state management in Jetpack Compose is essential for building robust, performant, and maintainable Android applications. Start with simple <code>remember</code> for local UI state, use state hoisting for shared state, and leverage ViewModel for complex business logic.</p>

                    <p>Remember these key principles: maintain a single source of truth, ensure unidirectional data flow, use immutable data structures, and scope your state appropriately. With these patterns and best practices, you'll be well-equipped to handle even the most complex state management scenarios in your Compose applications.</p>

                    <p>Happy coding with Compose!</p>
                </div>
            </article>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 xml2compose.dev. All rights reserved.</p>
        </div>
    </footer>
</body>
</html>
