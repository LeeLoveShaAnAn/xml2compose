<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F2G7TSB6Q6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-F2G7TSB6Q6');
    </script>
    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2819959179592334" 
      crossorigin="anonymous"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Animation Techniques in Jetpack Compose - xml2compose.dev</title>
    <meta name="description" content="Master Jetpack Compose animations with comprehensive examples covering transitions, gestures, and complex animation sequences.">
    
    <!-- Favicon -->
    <link rel="icon" href="../favicon.ico" type="image/x-icon">
    
    <!-- SEO Meta Tags -->
    <link rel="canonical" href="https://xml2compose.dev/blog/compose-animations.html">
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
    <meta property="og:title" content="Advanced Animation Techniques in Jetpack Compose">
    <meta property="og:description" content="Master Jetpack Compose animations with comprehensive examples covering transitions, gestures, and complex animation sequences.">
    <meta property="og:image" content="https://images.unsplash.com/photo-1517180102446-f3ece451e9d8?w=1200&h=630&fit=crop">
    <meta property="og:url" content="https://xml2compose.dev/blog/compose-animations.html">
    <meta property="og:type" content="article">
    
    <link rel="stylesheet" href="../style.css">
    <style>
        /* Article-specific styles */
        .main {
            min-height: calc(100vh - 64px - 200px);
            padding: var(--space-12) 0;
        }
        
        .article {
            background-color: var(--bg-primary);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-md);
            overflow: hidden;
            border: 1px solid var(--border-secondary);
        }
        
        .article-header {
            padding: var(--space-12) var(--space-8) var(--space-8);
            background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-primary) 100%);
        }
        
        .article-title {
            font-size: clamp(var(--text-3xl), 4vw, var(--text-5xl));
            font-weight: var(--font-bold);
            line-height: var(--leading-tight);
            margin-bottom: var(--space-4);
            color: var(--text-primary);
            letter-spacing: -0.025em;
        }
        
        .article-meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-6);
            font-size: var(--text-sm);
            color: var(--text-secondary);
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: var(--space-1);
        }
        
        .meta-icon {
            width: 1rem;
            height: 1rem;
            opacity: 0.6;
        }
        
        .article-content {
            padding: 0 var(--space-8) var(--space-12);
        }
        
        .article-content > * + * {
            margin-top: var(--space-6);
        }
        
        .article-content h2 {
            font-size: var(--text-3xl);
            font-weight: var(--font-bold);
            margin-top: var(--space-12);
            margin-bottom: var(--space-4);
            color: var(--text-primary);
        }
        
        .article-content h3 {
            font-size: var(--text-2xl);
            font-weight: var(--font-semibold);
            margin-top: var(--space-8);
            margin-bottom: var(--space-3);
            color: var(--text-primary);
        }
        
        .article-content p {
            color: var(--text-secondary);
            line-height: var(--leading-relaxed);
            font-size: var(--text-lg);
        }
        
        .article-content a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: var(--font-medium);
            border-bottom: 1px solid transparent;
            transition: border-color var(--transition-fast);
        }
        
        .article-content a:hover {
            border-bottom-color: var(--primary-color);
        }
        
        .code-block {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
            border-radius: var(--radius-md);
            overflow: hidden;
            margin: var(--space-6) 0;
        }
        
        .code-header {
            background-color: var(--bg-secondary);
            padding: var(--space-3) var(--space-4);
            border-bottom: 1px solid var(--border-secondary);
            font-size: var(--text-sm);
            color: var(--text-secondary);
            font-weight: var(--font-medium);
        }
        
        pre {
            padding: var(--space-4);
            overflow-x: auto;
            font-size: var(--text-sm);
            line-height: var(--leading-normal);
            margin: 0;
            font-family: var(--font-mono);
        }
        
        code {
            font-family: var(--font-mono);
            color: var(--text-primary);
        }
        
        .article-content p code {
            background-color: var(--bg-tertiary);
            padding: var(--space-1) var(--space-2);
            border-radius: var(--radius-sm);
            font-size: 0.875em;
            color: var(--accent-color);
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 2rem;
            transition: color 0.2s;
        }
        
        .back-link:hover {
            color: var(--secondary-color);
        }
        
        .back-icon {
            width: 1rem;
            height: 1rem;
        }
        
        @media (max-width: 768px) {
            .article-title {
                font-size: 2rem;
            }
            
            .article-header {
                padding: 2rem 1.5rem 1.5rem;
            }
            
            .article-content {
                padding: 0 1.5rem 2rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="logo">
                <h1 class="logo-text"><a href="../index.html">xml2compose.dev</a></h1>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../converter.html">Converter</a></li>
                    <li><a href="../blog.html">Blog</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <a href="../blog.html" class="back-link">
                <svg class="back-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
                Back to Blog
            </a>
            
            <article class="article">
                <header class="article-header">
                    <h1 class="article-title">Advanced Animation Techniques in Jetpack Compose</h1>
                    <div class="article-meta">
                        <span class="meta-item">
                            <svg class="meta-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            January 22, 2025
                        </span>
                        <span class="meta-item">
                            <svg class="meta-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            12 min read
                        </span>
                        <span class="meta-item">
                            <svg class="meta-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                            </svg>
                            xml2compose Team
                        </span>
                    </div>
                </header>

                <div class="article-content">
                    <p>Animations breathe life into your Android applications, creating engaging user experiences that feel natural and responsive. Jetpack Compose provides a powerful and intuitive animation system that makes creating complex animations easier than ever before. In this comprehensive guide, we'll explore advanced animation techniques and best practices.</p>

                    <h2>Animation Fundamentals</h2>

                    <p>Compose animations are built around the concept of animating between states. The framework provides several APIs for different use cases, from simple value animations to complex transitions.</p>

                    <h3>Basic Value Animations</h3>

                    <p>The foundation of Compose animations is <code>animateFloatAsState</code> and similar functions for different data types:</p>

                    <div class="code-block">
                        <div class="code-header">BasicAnimation.kt</div>
                        <pre><code>@Composable
fun PulsatingButton() {
    var isPressed by remember { mutableStateOf(false) }
    
    val scale by animateFloatAsState(
        targetValue = if (isPressed) 0.95f else 1f,
        animationSpec = spring(
            dampingRatio = Spring.DampingRatioMediumBouncy,
            stiffness = Spring.StiffnessLow
        ),
        label = "button_scale"
    )
    
    val alpha by animateFloatAsState(
        targetValue = if (isPressed) 0.8f else 1f,
        animationSpec = tween(durationMillis = 150),
        label = "button_alpha"
    )
    
    Button(
        onClick = { /* Handle click */ },
        modifier = Modifier
            .scale(scale)
            .alpha(alpha)
            .pointerInput(Unit) {
                detectTapGestures(
                    onPress = {
                        isPressed = true
                        tryAwaitRelease()
                        isPressed = false
                    }
                )
            }
    ) {
        Text("Press Me")
    }
}</code></pre>
                    </div>

                    <h3>Color and Size Animations</h3>

                    <p>Animate colors and sizes using dedicated animation functions:</p>

                    <div class="code-block">
                        <div class="code-header">ColorSizeAnimation.kt</div>
                        <pre><code>@Composable
fun AnimatedCard(isSelected: Boolean) {
    val backgroundColor by animateColorAsState(
        targetValue = if (isSelected) 
            MaterialTheme.colorScheme.primaryContainer 
        else 
            MaterialTheme.colorScheme.surface,
        animationSpec = tween(durationMillis = 300),
        label = "card_background"
    )
    
    val elevation by animateDpAsState(
        targetValue = if (isSelected) 8.dp else 2.dp,
        animationSpec = spring(
            dampingRatio = Spring.DampingRatioMediumBouncy
        ),
        label = "card_elevation"
    )
    
    val cornerRadius by animateDpAsState(
        targetValue = if (isSelected) 16.dp else 8.dp,
        animationSpec = tween(durationMillis = 300),
        label = "card_corner"
    )
    
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp),
        colors = CardDefaults.cardColors(
            containerColor = backgroundColor
        ),
        elevation = CardDefaults.cardElevation(
            defaultElevation = elevation
        ),
        shape = RoundedCornerShape(cornerRadius)
    ) {
        Text(
            text = "Animated Card",
            modifier = Modifier.padding(16.dp)
        )
    }
}</code></pre>
                    </div>

                    <h2>Advanced Transition Animations</h2>

                    <h3>AnimatedVisibility</h3>

                    <p><code>AnimatedVisibility</code> provides smooth enter and exit animations for composables:</p>

                    <div class="code-block">
                        <div class="code-header">AnimatedVisibility.kt</div>
                        <pre><code>@Composable
fun ExpandableCard() {
    var isExpanded by remember { mutableStateOf(false) }
    
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
            .clickable { isExpanded = !isExpanded }
    ) {
        Column {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Expandable Content",
                    style = MaterialTheme.typography.titleMedium
                )
                
                Icon(
                    imageVector = if (isExpanded) 
                        Icons.Default.ExpandLess 
                    else 
                        Icons.Default.ExpandMore,
                    contentDescription = if (isExpanded) "Collapse" else "Expand",
                    modifier = Modifier.rotate(
                        animateFloatAsState(
                            targetValue = if (isExpanded) 180f else 0f,
                            label = "arrow_rotation"
                        ).value
                    )
                )
            }
            
            AnimatedVisibility(
                visible = isExpanded,
                enter = slideInVertically(
                    animationSpec = tween(300)
                ) + expandVertically(
                    animationSpec = tween(300)
                ) + fadeIn(
                    animationSpec = tween(300)
                ),
                exit = slideOutVertically(
                    animationSpec = tween(300)
                ) + shrinkVertically(
                    animationSpec = tween(300)
                ) + fadeOut(
                    animationSpec = tween(300)
                )
            ) {
                Text(
                    text = "This is the expanded content that appears with a smooth animation. " +
                           "You can add any composable content here.",
                    modifier = Modifier.padding(16.dp),
                    style = MaterialTheme.typography.bodyMedium
                )
            }
        }
    }
}</code></pre>
                    </div>

                    <h3>Crossfade Transitions</h3>

                    <p>Use <code>Crossfade</code> for smooth transitions between different content:</p>

                    <div class="code-block">
                        <div class="code-header">CrossfadeExample.kt</div>
                        <pre><code>@Composable
fun TabContent() {
    var selectedTab by remember { mutableStateOf(0) }
    
    Column {
        TabRow(selectedTabIndex = selectedTab) {
            Tab(
                selected = selectedTab == 0,
                onClick = { selectedTab = 0 },
                text = { Text("Home") }
            )
            Tab(
                selected = selectedTab == 1,
                onClick = { selectedTab = 1 },
                text = { Text("Profile") }
            )
            Tab(
                selected = selectedTab == 2,
                onClick = { selectedTab = 2 },
                text = { Text("Settings") }
            )
        }
        
        Crossfade(
            targetState = selectedTab,
            animationSpec = tween(300),
            label = "tab_content"
        ) { tab ->
            when (tab) {
                0 -> HomeContent()
                1 -> ProfileContent()
                2 -> SettingsContent()
            }
        }
    }
}

@Composable
fun HomeContent() {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(MaterialTheme.colorScheme.primaryContainer),
        contentAlignment = Alignment.Center
    ) {
        Text("Home Content")
    }
}</code></pre>
                    </div>

                    <h2>Complex Animation Sequences</h2>

                    <h3>Animatable for Custom Animations</h3>

                    <p>For more control over animations, use <code>Animatable</code>:</p>

                    <div class="code-block">
                        <div class="code-header">CustomAnimation.kt</div>
                        <pre><code>@Composable
fun BouncingBall() {
    val animatable = remember { Animatable(0f) }
    
    LaunchedEffect(Unit) {
        while (true) {
            // Bounce down
            animatable.animateTo(
                targetValue = 200f,
                animationSpec = tween(
                    durationMillis = 800,
                    easing = FastOutSlowInEasing
                )
            )
            
            // Bounce back up
            animatable.animateTo(
                targetValue = 0f,
                animationSpec = tween(
                    durationMillis = 600,
                    easing = FastOutLinearInEasing
                )
            )
            
            // Small pause at the top
            delay(200)
        }
    }
    
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .height(250.dp)
    ) {
        Box(
            modifier = Modifier
                .size(50.dp)
                .offset(y = animatable.value.dp)
                .background(
                    color = MaterialTheme.colorScheme.primary,
                    shape = CircleShape
                )
                .align(Alignment.TopCenter)
        )
    }
}</code></pre>
                    </div>

                    <h3>Infinite Animations</h3>

                    <p>Create continuous animations using <code>rememberInfiniteTransition</code>:</p>

                    <div class="code-block">
                        <div class="code-header">InfiniteAnimation.kt</div>
                        <pre><code>@Composable
fun LoadingSpinner() {
    val infiniteTransition = rememberInfiniteTransition(label = "spinner")
    
    val rotation by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 360f,
        animationSpec = infiniteRepeatable(
            animation = tween(
                durationMillis = 1000,
                easing = LinearEasing
            )
        ),
        label = "rotation"
    )
    
    val scale by infiniteTransition.animateFloat(
        initialValue = 0.8f,
        targetValue = 1.2f,
        animationSpec = infiniteRepeatable(
            animation = tween(
                durationMillis = 800,
                easing = FastOutSlowInEasing
            ),
            repeatMode = RepeatMode.Reverse
        ),
        label = "scale"
    )
    
    Box(
        modifier = Modifier
            .size(60.dp)
            .scale(scale)
            .rotate(rotation)
            .background(
                brush = Brush.sweepGradient(
                    colors = listOf(
                        Color.Transparent,
                        MaterialTheme.colorScheme.primary,
                        MaterialTheme.colorScheme.secondary
                    )
                ),
                shape = CircleShape
            )
    )
}</code></pre>
                    </div>

                    <h2>Gesture-Based Animations</h2>

                    <h3>Swipe to Dismiss</h3>

                    <p>Combine gestures with animations for interactive experiences:</p>

                    <div class="code-block">
                        <div class="code-header">SwipeToDismiss.kt</div>
                        <pre><code>@Composable
fun SwipeableCard(
    onDismiss: () -> Unit,
    content: @Composable () -> Unit
) {
    val offsetX = remember { Animatable(0f) }
    val alpha = remember { Animatable(1f) }
    
    Box(
        modifier = Modifier
            .offset(x = offsetX.value.dp)
            .alpha(alpha.value)
            .pointerInput(Unit) {
                detectHorizontalDragGestures(
                    onDragEnd = {
                        val velocity = offsetX.velocity
                        val offset = offsetX.value
                        
                        if (abs(offset) > size.width * 0.3f || abs(velocity) > 1000f) {
                            // Dismiss the card
                            launch {
                                val targetOffset = if (offset > 0) size.width.toFloat() else -size.width.toFloat()
                                launch {
                                    offsetX.animateTo(
                                        targetValue = targetOffset,
                                        animationSpec = tween(300)
                                    )
                                }
                                launch {
                                    alpha.animateTo(
                                        targetValue = 0f,
                                        animationSpec = tween(300)
                                    )
                                }
                                onDismiss()
                            }
                        } else {
                            // Snap back to center
                            launch {
                                offsetX.animateTo(
                                    targetValue = 0f,
                                    animationSpec = spring(
                                        dampingRatio = Spring.DampingRatioMediumBouncy
                                    )
                                )
                            }
                        }
                    }
                ) { _, dragAmount ->
                    launch {
                        offsetX.snapTo(offsetX.value + dragAmount)
                        // Update alpha based on offset
                        alpha.snapTo(1f - abs(offsetX.value) / size.width * 0.5f)
                    }
                }
            }
    ) {
        content()
    }
}</code></pre>
                    </div>

                    <h3>Pull to Refresh</h3>

                    <p>Create a custom pull-to-refresh animation:</p>

                    <div class="code-block">
                        <div class="code-header">PullToRefresh.kt</div>
                        <pre><code>@Composable
fun PullToRefreshList(
    items: List<String>,
    isRefreshing: Boolean,
    onRefresh: () -> Unit
) {
    val pullToRefreshState = rememberPullToRefreshState()
    
    Box(
        modifier = Modifier
            .fillMaxSize()
            .pullToRefresh(
                state = pullToRefreshState,
                isRefreshing = isRefreshing,
                onRefresh = onRefresh
            )
    ) {
        LazyColumn(
            modifier = Modifier.fillMaxSize(),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            items(items) { item ->
                Card(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(
                        text = item,
                        modifier = Modifier.padding(16.dp)
                    )
                }
            }
        }
        
        PullToRefreshContainer(
            state = pullToRefreshState,
            modifier = Modifier.align(Alignment.TopCenter)
        )
    }
}</code></pre>
                    </div>

                    <h2>Performance Optimization</h2>

                    <h3>Animation Performance Tips</h3>

                    <p>Follow these best practices to ensure smooth animations:</p>

                    <ul style="margin: 1rem 0; padding-left: 2rem; color: var(--text-secondary);">
                        <li style="margin: 0.5rem 0;">Use <code>remember</code> for animation objects to avoid recreation</li>
                        <li style="margin: 0.5rem 0;">Prefer <code>animateFloatAsState</code> over manual <code>Animatable</code> when possible</li>
                        <li style="margin: 0.5rem 0;">Use appropriate animation specs (spring for interactive, tween for choreographed)</li>
                        <li style="margin: 0.5rem 0;">Avoid animating expensive operations in the composition phase</li>
                        <li style="margin: 0.5rem 0;">Use <code>graphicsLayer</code> for transform animations to avoid layout passes</li>
                    </ul>

                    <div class="code-block">
                        <div class="code-header">OptimizedAnimation.kt</div>
                        <pre><code>@Composable
fun OptimizedAnimatedBox(isExpanded: Boolean) {
    val scale by animateFloatAsState(
        targetValue = if (isExpanded) 1.2f else 1f,
        label = "scale"
    )
    
    val rotation by animateFloatAsState(
        targetValue = if (isExpanded) 45f else 0f,
        label = "rotation"
    )
    
    Box(
        modifier = Modifier
            .size(100.dp)
            // Use graphicsLayer for transform animations
            .graphicsLayer {
                scaleX = scale
                scaleY = scale
                rotationZ = rotation
            }
            .background(
                color = MaterialTheme.colorScheme.primary,
                shape = RoundedCornerShape(8.dp)
            )
    )
}</code></pre>
                    </div>

                    <h2>Animation Testing</h2>

                    <p>Testing animations ensures they work correctly across different scenarios:</p>

                    <div class="code-block">
                        <div class="code-header">AnimationTest.kt</div>
                        <pre><code>@Test
fun testButtonAnimation() {
    composeTestRule.setContent {
        var isPressed by remember { mutableStateOf(false) }
        
        Button(
            onClick = { isPressed = !isPressed },
            modifier = Modifier.testTag("animated_button")
        ) {
            Text("Click me")
        }
    }
    
    // Verify initial state
    composeTestRule
        .onNodeWithTag("animated_button")
        .assertExists()
    
    // Trigger animation
    composeTestRule
        .onNodeWithTag("animated_button")
        .performClick()
    
    // Advance clock to let animation complete
    composeTestRule.mainClock.advanceTimeBy(1000L)
    
    // Verify animation completed
    composeTestRule.waitForIdle()
}</code></pre>
                    </div>

                    <h2>Conclusion</h2>

                    <p>Mastering animations in Jetpack Compose opens up endless possibilities for creating engaging and delightful user experiences. From simple state-driven animations to complex gesture-based interactions, Compose provides the tools you need to bring your UI to life.</p>

                    <p>Remember to start simple with basic animations, then gradually incorporate more advanced techniques as needed. Always consider performance implications and test your animations across different devices and scenarios.</p>

                    <p>The key to great animations is subtlety and purpose â€“ they should enhance the user experience without being distracting. Use the techniques and patterns covered in this guide to create animations that feel natural and add real value to your applications.</p>

                    <p>Happy animating with Compose!</p>
                </div>
            </article>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 xml2compose.dev. All rights reserved.</p>
        </div>
    </footer>
</body>
</html>
